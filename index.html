<!DOCTYPE html>
<html>
<body>

    <link rel="stylesheet" href="stylesheet.css">

    <div id = "noodleZoneAndCreator" class = "row">
        <div id = "noodleZone" class = "row"></div>
        <div class = "noodleColumn" style = "width:150px">
            Add a new noodle
            with the following
            length:<br>
            <input type="number" min="1" value="1" style="width:50%" id="newNoodleNumInput">
            <br>
            <input type="button" style="font-size:16px" value="Add Noodle" onclick="add_noodle_pressed()">
            <div id="newNoodleErrorBox" style="color:red"></div>
        </div>
    </div>

    <div class="row"><div class = "column50">

    

    <div id="lengthSum"></div>
    Empty tiles in grid: <div id="emptyTileSum">81</div>


    <br><br>

    Advanced Settings:

    <br><br>

    Enter Turning Chance:
    <input type="text" id="turnChanceEntry" name="turnChanceEntry" value="1">

    <br>
    (Must be a number between 0 and 1)
    <br>
    (Higher means more "wiggly" lines, which usually means harder puzzles)
    <br>
    (If its taking a long time to generate, try reducing this number)


    <br><br>

    Enter Highest Length of Straight Line Allowed:
    <input type="text" id="straightLimitEntry" value="5">
    <br>
    (If left blank, there will be no limit)

    <br><br>

    <label for="presetSelect">Choose a saved preset:</label>
    <select name="presetSelect" id="presetSelect" onchange="load_pressed()"></select>
    <input id="loadButton" type="button" value="Load" onclick="load_pressed();" >

    <br><br>
    
    Save current layout:
    <input type="text" id="presetNameEntry" value="enter name here">
    <input id="saveButton" type="button" value="Save" onclick="save_pressed();" >

    <br><br>
    
    <input id="genButton" type="button" style="font-size:20px;" value="Generate" onclick="gen_pressed();" >

    <div id="errorMessage"></div>

    <div id="generatingMessage"></div>

    </div><div class="column50" id="settingsGridHolder">

    Click the tiles on the grid to remove/add them from the puzzle:

    <br>

    </div></div>

    





<!--Main Javascript-->
<script>
// tracks whether the web worker is currently generating a puzzle
// (Doesnt let it start another if true)
let generating = false;

// the grid that determines the shape of the puzzle
// 11x11 with "X" on the outer border (so there is a 9x9 within)
let initGrid = [["X","X","X","X","X","X","X","X","X","X","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X","X","X","X","X","X","X","X","X","X","X"]];

// the characteristics of all noodles (enabled and disabled) currently on the page
let noodleData = [];

// the web worker that generates the puzzles
let genWorker = new Worker("generator.js");
//let genWorker = new Worker(new URL('../generator.js', "http://localhost:8000/website.html"));

// list of lists for each generated puzzle [solutionShowing (true/false), puzzle, elementGrid, button object]
let activePuzzles = [];

// tracks which presets are currently available to the user
let savedPresets = [];

// runs upon the puzzle being generated
genWorker.onmessage = function(event) {
    console.log("recieved message!");
    let puzzle = event.data;
    //outElement.innerHTML = event.data;
    for (let i = 0; i < puzzle[1].length; i++){
        let noodle = puzzle[1][i];
        console.log("Icon: " + noodle.icon);
        console.log("Length: " + String(noodle.length));
        console.log(noodle.start);
        console.log(noodle.end);
    }

    display_grid(puzzle);
    generating = false;
    document.getElementById("generatingMessage").innerHTML = "Done!";
};

// generating the grid to change puzzle size
let settingsGridDiv = document.createElement("div");
settingsGridDiv.className = "puzzleGrid";
document.getElementById("settingsGridHolder").appendChild(settingsGridDiv);

let settingsGridElements = [];
for (let i = 0; i < 9; i++){
    let newRow = [];
    for (let j = 0; j < 9; j++){
        newRow.push(document.createElement("div"));
        newRow[j].className = "tile";
        newRow[j].style.backgroundColor = "lightgrey";
        newRow[j].onclick = function () {
            setting_tile_clicked(i,j);
        }
        settingsGridDiv.appendChild(newRow[j]);
    }
    settingsGridElements.push(newRow);
}


setup_page();




// -----===== FUNCTIONS =====-----

// runs when the page is loaded
// allows setup without creating unneccessary global variables
function setup_page(){
    
    
    // if there is no local storage, creates one
    if (localStorage.getItem("presetNames") == null){
        localStorage.setItem("presetNames","");
    }
    
    // loads presets into savedPresets, and updates the dropdown menu
    update_presets();

    // loads the preset in the first slot, ie the default one
    load_pressed();

    // updates the noodle display to show the correct data
    refresh_noodles();

    // updates the length sum display
    update_length_sum();

}

// loads all preset names from local storage "presetNames"
// then returns them formatted correctly as a list
// note the fact this uses split means the names cannot include commas
// relies on the fact that the names are strings and not arrays
function get_preset_names(){
    let rawList = localStorage.getItem("presetNames").split(",");
    if (are_arrays_equal(rawList,[""])){
        return [];
    } else {
        return rawList;
    }

}

// updates the savedPresets function
// and dropdown menu html
// to include only default presets and those saved locally
function update_presets(){
    // resets preset list to default(s)
    savedPresets = [["default",[[[6,[true],"red"],[7,[true,true],"orange"],[9,[true,true],"yellow"],[11,[true],"green"],[14,[true],"blue"],[18,[true],"purple"],[1,[false,false,false,false,false],"darkslategrey"]],1,[["X","X","X","X","X","X","X","X","X","X","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X","X","X","X","X","X","X","X","X","X","X"]],5]]];
    //savedPresets.push(["NIGHTMARE MODE",[[[6,[true],"red"],[7,[true,true],"orange"],[9,[true,true],"yellow"],[11,[true],"green"],[14,[true],"blue"],[18,[true],"purple"],[1,[false,false,false,false,false],"darkslategrey"]],1,[["X","X","X","X","X","X","X","X","X","X","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," ","X"," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X"," "," "," "," "," "," "," "," "," ","X"],["X","X","X","X","X","X","X","X","X","X","X"]],5,true]]);

    // loads all presets from the local storage
    let presetNames = get_preset_names(); // note this means names cant have commas in them
    for (let i = 0; i < presetNames.length; i++){
        savedPresets.push(read_preset(presetNames[i]))
    }

    // clears dropdown menu
    document.getElementById("presetSelect").innerHTML = "";

    // adds all loaded presets as options in the load dropdown menu
    for (let i = 0; i < savedPresets.length; i++){
        let newOption = document.createElement("option");
        // sets the value and display text to be the presets name
        newOption.value = savedPresets[i][0];
        newOption.innerHTML = savedPresets[i][0];
        document.getElementById("presetSelect").appendChild(newOption);
    }
}


// clears and rebuilds the section that displays the noodles
function refresh_noodles() {
    let noodleZone = document.getElementById("noodleZone");
    let coloursList = get_remaining_colours();
    // clears previous html from display
    noodleZone.innerHTML = "";
    // for each unique length, builds a column
    for (let i = 0; i < noodleData.length; i++){
        // creates the column
        let newColumn = document.createElement("div");
        newColumn.className = "noodleColumn";
        noodleZone.appendChild(newColumn);
        // creates the dot with the noodles length and colour
        let noodleCircle = document.createElement("div");
        noodleCircle.className = "noodleDot";
        noodleCircle.innerHTML = String(noodleData[i][0]);
        noodleCircle.style.backgroundColor = noodleData[i][2];
        newColumn.appendChild(noodleCircle);
        newColumn.appendChild(document.createElement("br"));
        newColumn.appendChild(document.createElement("br"));
        // creates a checkbox for each noodle
        for (let j = 0; j < noodleData[i][1].length; j++){
            let newCheckbox = document.createElement("input");
            newCheckbox.type = "checkbox";
            newCheckbox.checked = noodleData[i][1][j];
            // when flipped, flips the corresponding variable
            newCheckbox.onclick = function () {
                noodleData[i][1][j] = !(noodleData[i][1][j]);
                update_length_sum();
            }
            newColumn.appendChild(newCheckbox)
        }
        newColumn.appendChild(document.createElement("br"));
        newColumn.appendChild(document.createElement("br"));
        // creates the dropdown to pick a colour
        let newDropdown = document.createElement("select");
        // sets the default to just say "Colour"
        let defaultOption = document.createElement("option");
        newDropdown.appendChild(defaultOption);
        defaultOption.value = "Colour";
        defaultOption.innerHTML = "Colour";
        newDropdown.value = "Colour";
        // adds each (remaining) colour as an option to the dropdown menu
        for (let j = 0; j < coloursList.length; j++){
            let newOption = document.createElement("option");
            newOption.innerHTML = coloursList[j];
            newOption.value = coloursList[j];
            newDropdown.appendChild(newOption);
        }
        // on picking a colour, updates the noodleData, then updates the GUI
        newDropdown.onchange = function () {
            noodleData[i][2] = newDropdown.value;
            refresh_noodles();
        }
        newColumn.appendChild(newDropdown);
        newColumn.appendChild(document.createElement("br"));
        // creates the remove button
        let newButton = document.createElement("input");
        newButton.type = "button";
        newButton.style.fontSize = "16px";
        newButton.value = "Remove";
        // on click, removes the last noodle from this lengths data
        // if there was only one left, removes the entire length from the data
        // then updates the GUI
        newButton.onclick = function () {
            if (noodleData[i][1].length == 1){
                noodleData.splice(i,1);
            } else {
                noodleData[i][1].pop();
            }
            refresh_noodles();
            update_length_sum();
        }
        newColumn.appendChild(newButton);
    }
}

// runs when the generate button is pressed
function gen_pressed() {
    if (!generating){
        // Starting the generation of the puzzle
        let parameters = get_parameters();
        if (parameters == false){
            return;
        }
        genWorker.postMessage(parameters);
        generating = true;
        document.getElementById("generatingMessage").innerHTML = "Currently generating...";
    }
}

// runs when the "add noodle" button in the noodle display is clicked 
function add_noodle_pressed(){
    let coloursList = get_remaining_colours();
    let numberInput = document.getElementById("newNoodleNumInput");
    let newLength = parseInt(numberInput.value);
    // clears the error box first
    document.getElementById("newNoodleErrorBox").innerHTML = "";
    // check if the input is a valid number
    if (isNaN(newLength)){
        document.getElementById("newNoodleErrorBox").innerHTML = "Please enter a number";
        return;
    } else if (newLength < 1){
        document.getElementById("newNoodleErrorBox").innerHTML = "Please enter a number greater than 0";
        return;
    }
    // gets if the length is new or not
    // -1 is new
    let lengthIndex = -1;
    for (let i = 0; i < noodleData.length; i++){
        if (newLength == noodleData[i][0]){
            lengthIndex = i;
        }
    }
    // if new
    if (lengthIndex != -1){
        noodleData[lengthIndex][1].push(false);
    // if not new
    } else {
        noodleData.push([newLength,[false],coloursList[0]])
    }
    refresh_noodles();
}

// runs upon the "load" button being pressed
// checks the preset drop down menu
// if a saved preset with that name exists, loads it
function load_pressed() {
    let presetName = document.getElementById("presetSelect").value;
    let presetNameList = savedPresets.map(x => x[0]);
    // the first element of each savedPreset is its name
    if (presetNameList.includes(presetName)){
        let presetIndex = presetNameList.indexOf(presetName);
        // the second element of each savedPreset is the list of parameters
        load_parameters(savedPresets[presetIndex][1]);
    } else {
        console.log("no such preset name exists!");
    }
}

// runs when the save preset button is pressed
// takes the current data and saves it to the name entered
function save_pressed(){
    console.log("saving!");
    let nameEntry = document.getElementById("presetNameEntry").value;
    if (nameEntry == ""){
        document.getElementById("errorMessage").innerHTML = "Cant save preset: Please enter a name";
        return;
    }
    if (nameEntry.includes(",")){
        document.getElementById("errorMessage").innerHTML = "Cant save preset: Please do not use commas in name";
        return;
    }

    // gets parameters
    // this has in built checks to see if they are valid for generating
    // if these checks fail, return (dont save)
    let parameters = get_parameters();
    if (parameters == false){
        return;
    }

    // structure of a preset:
    // ["presetName", [[noodleData],int turning chance, [[2d grid array]], straight limit]]

    // if all checks are passed:
    
    let presetToSave = [nameEntry,parameters];
    // saves to file
    save_preset(presetToSave);

    // updates savedPresets and dropdown menu
    update_presets();

    // updates text to confirm save
    document.getElementById("errorMessage").innerHTML = "Successfully saved preset!";
}

// saves the preset to local storage
function save_preset(preset){
    // format [presetName,[[[noodleData]],turning chance,[[2d grid array]],straight limit]]
    let presetName = preset[0];

    // if its a new preset name, adds it to the list of preset names
    let presetNames = get_preset_names();

    if (!presetNames.includes(presetName)) {
        presetNames.push(presetName);
        localStorage.setItem("presetNames",presetNames.toString());
    }

    // convert and save noodle data to local storage
    // noodleDataString is separated by semicolons, then the list of booleans is separated by commas
    let noodleDataString = "";
    let presetNoodleData = preset[1][0];
    for (let i = 0; i < presetNoodleData.length; i++){
        // the single element of noodleData corresponding to a length
        // [length int, [array of booleans], colour string]
        let presetLengthData = presetNoodleData[i];
        // this array converted to a string
        let lengthDataString = "";
        // adds the length to the string
        lengthDataString = lengthDataString + String(presetLengthData[0]) + ";";
        // adds the list of booleans to the string
        let boolListString = "";
        for (let j = 0; j < presetLengthData[1].length; j++){
            boolListString = boolListString + String(presetLengthData[1][j]) + ",";
        }
        // cuts off the last comma since its not separating 2 elements
        boolListString = boolListString.slice(0,-1);
        // add the bool list string to the string for this length
        lengthDataString = lengthDataString + boolListString + ";";
        // adds the colour to the string
        lengthDataString = lengthDataString + presetLengthData[2];

        // adds this length to the noodleData string, separated by full stops
        noodleDataString = noodleDataString + lengthDataString + ".";
    }
    // cuts off last unused full stop
    noodleDataString = noodleDataString.slice(0,-1);
    
    // saves to local storage
    localStorage.setItem(presetName + "noodleData",noodleDataString);

    // save turning chance to local storage
    localStorage.setItem(presetName + "turnChance", String(preset[1][1]));

    // convert and save the 2d grid to local storage
    // gridString separates by semicolon, then separates subarrays by commas
    let gridString = "";
    let grid = preset[1][2];
    for (let i = 0; i < 11; i++){
        for (let j = 0; j < 11; j++){
            gridString = gridString + grid[i][j] + ",";
        }
        gridString = gridString.slice(0,-1) + ";"; 
    }
    gridString = gridString.slice(0,-1); 
    localStorage.setItem(presetName + "gridArray",gridString);

    // save the straight limit to local storage
    localStorage.setItem(presetName + "straightLimit",String(preset[1][3]));
}

// reads a preset from the local storage and returns it
function read_preset(presetName) {
    // format [presetName,[[[noodleData]],turning chance,[[2d grid array]],straight limit]]
    let newPreset = [presetName,[]];

    // get noodleData
    // noodleData has format:
    // ARRAY OF ELEMENTS of format [noodle length int, [list of noodle activation status booleans], noodle colour string]
    let rawNoodleDataArray = localStorage.getItem(presetName + "noodleData").split(".");
    let presetNoodleData = [];

    // for each noodle length
    for (let i = 0; i < rawNoodleDataArray.length; i++){
        // the single length's array that will be pushed to the new noodleData
        let presetLengthData = [];
        // the split string corresponding to a single length's data
        let rawLengthArray = rawNoodleDataArray[i].split(";");
        // adds length integer
        presetLengthData.push(parseInt(rawLengthArray[0]));
        // adds list of activation booleans
        let boolList = [];
        let boolStrings = rawLengthArray[1].split(",");
        for (let j = 0; j < boolStrings.length; j++){
            boolList.push(boolStrings[j] == "true");
        }
        presetLengthData.push(boolList);
        // adds noodle colour string
        presetLengthData.push(rawLengthArray[2]);
        
        // pushes to new noodleData array
        presetNoodleData.push(presetLengthData);
    }
    

    
    // adds noodle data to preset to return
    newPreset[1].push(presetNoodleData);

    // get turn chance
    newPreset[1].push(parseFloat(localStorage.getItem(presetName + "turnChance")));

    // get 2d grid array
    let gridString = localStorage.getItem(presetName + "gridArray");
    let rowStrings = gridString.split(";");
    let newGrid = [];
    for (let i = 0; i < 11; i++){
        newGrid.push(rowStrings[i].split(","));
    }
    newPreset[1].push(newGrid);

    // get straight limit (integer)
    newPreset[1].push(parseInt(localStorage.getItem(presetName + "straightLimit")));

    return newPreset;
}

// runs when one of the tiles in the grid editor is clicked
// swaps the tile from grey to black (or vice versa) and edits initGrid to block/allow that tile
function setting_tile_clicked(row,column){
    if (initGrid[row+1][column+1] == " ") {
        initGrid[row+1][column+1] = "X";
        settingsGridElements[row][column].style.backgroundColor = "black";
        // subtracts 1 from the sum of empty tiles tracker
        document.getElementById("emptyTileSum").innerHTML = String(parseInt(document.getElementById("emptyTileSum").innerHTML) - 1);
    } else {
        initGrid[row+1][column+1] = " ";
        settingsGridElements[row][column].style.backgroundColor = "lightgrey";
        // adds 1 to the sum of empty tiles tracker
        document.getElementById("emptyTileSum").innerHTML = String(parseInt(document.getElementById("emptyTileSum").innerHTML) + 1);
    }
}

// returns a list of all colours not currently being used by a noodle
function get_remaining_colours(){
    let coloursList = ["red","orange","yellow","green","blue","purple","hotpink","lightblue","limegreen","cyan","maroon","orchid","tan","darkslategrey","goldenrod","seagreen","slategrey","teal","saddlebrown","lavender"];
    //removes colours already being used from the list
    for (let i = 0; i < noodleData.length; i++){
        let removeIndex = coloursList.indexOf(noodleData[i][2]);
        coloursList.splice(removeIndex,1);
    }
    return coloursList;

}

// updates the html text display showing the sum of the lengths of activated noodles
function update_length_sum(){
    // gets list of lengths of activated noodles
    let lengthList = get_length_list();
    // if theres more than 20 noodles activated, updates the display with a corresponding error
    if (lengthList.length > 20){
        document.getElementById("lengthSum").innerHTML = "Error: Cannot use more than 20 lengths";
        return;
    }
    // counts the sum
    let sum = 0;
    for (let i = 0; i < lengthList.length; i++){
        sum = sum + lengthList[i];
    }
    // updates the display with the sum
    document.getElementById("lengthSum").innerHTML = "Sum: " + String(sum);
}

// returns a list of the lengths of all the noodles currently selected
// uses the noodleData variable
function get_length_list(){
    let lengthList = [];
    // for each length
    for (let i = 0; i < noodleData.length; i++){
        // for each boolean noodle for that length
        for (let j = 0; j < noodleData[i][1].length; j++){
            // if its activated, adds its length to the list
            if (noodleData[i][1][j] == true){
                lengthList.push(noodleData[i][0]);
            }
        }
    }
    return lengthList;
}



// gets the current genParams and returns it
// also used to save layouts to load them later
function get_parameters(){
    // Checking length data to see if it is valid
    let lengthList = get_length_list();
    if (lengthList.length > 20){
        document.getElementById("errorMessage").innerHTML = "Error: Too many lengths";
        console.log("Error: Too many lengths");
        return false;
    }
    for (let i = 0; i < lengthList.length; i++){
        if (isNaN(lengthList[i])){
            console.log(lengthList[i]);
            document.getElementById("errorMessage").innerHTML = "Error: Non numbers found in lengths";
            console.log("Error: Non numbers found in lengths");
            return false;
        }
        lengthList[i] = Number(lengthList[i]);
    }
    if (!still_fillable(count_gaps(initGrid),lengthList)){
        document.getElementById("errorMessage").innerHTML = "Error: Cannot fill grid layout with current lengths";
        console.log("Error: Cannot fill grid layout with current lengths");
        return false;
    }
    // Checking turning chance data to see if it is valid
    let turnData = document.getElementById("turnChanceEntry").value;
    turnData = turnData.replaceAll(" ","");
    if (isNaN(turnData)) {
        document.getElementById("errorMessage").innerHTML = "Error: Non numbers found in turning chance";
        return false;
    }
    if ((turnData < 0) || (turnData > 1)) {
        document.getElementById("errorMessage").innerHTML = "Error: Turning Chance not between 0 and 1";
        return false;
    }
    
    // getting straightLimit data
    let straightLimit = document.getElementById("straightLimitEntry").value;
    straightLimit = parseInt(straightLimit);
    if (isNaN(straightLimit)) {
        straightLimit = 82; //ie, no limit
    }

    return [noodleData,parseFloat(turnData),initGrid,straightLimit];
}

function load_parameters(inputParams){
    let turnData = inputParams[1];
    let newGrid = inputParams[2];
    let straightLimit = inputParams[3];

    // updates noodleData
    noodleData = structuredClone(inputParams[0]);

    // updating turning chance
    document.getElementById("turnChanceEntry").value = String(turnData);

    // updating grid and empty tiles tracker
    update_grid(newGrid);

    // updating straight line limit
    document.getElementById("straightLimitEntry").value = String(straightLimit);

    // updates the noodle display and length sum
    refresh_noodles();
    update_length_sum();
}

// takes a new grid
// updates the grid editor to be the new one
// changes the tile colours and empty tile count to be the new one
function update_grid(newGrid){
    let icons = ["X"," "];
    let colours = ["black","lightgrey"];
    let sumDiff = [-1,1];
    for (let i = 1; i <= 9; i++){
        for (let j = 1; j <= 9; j++){
            if (initGrid[i][j] != newGrid[i][j]){
                console.log("icon: " + newGrid[i][j])
                let newColour = colours[icons.indexOf(newGrid[i][j])];
                console.log(newColour);
                // sets tile colour to the new one
                settingsGridElements[i-1][j-1].style.backgroundColor = newColour;
                // adds or subtracts from sum depending on new one
                document.getElementById("emptyTileSum").innerHTML = String(parseInt(document.getElementById("emptyTileSum").innerHTML) + sumDiff[icons.indexOf(newGrid[i][j])]);
            }
        }
    }
    initGrid = newGrid;
}





// creates html objects for displaying the puzzle solution and adds them to the document
function display_grid(puzzle){
    // unique identifier for which puzzle it is
    // starts at 0, increases for each generated
    let puzzleNum = activePuzzles.length;

    // adds small gap before displaying grid
    document.body.appendChild(document.createElement("br"));
    document.body.appendChild(document.createElement("br"));

    // text giving the number of the puzzle
    let puzzleTitle = document.createElement("div");
    puzzleTitle.className = "puzzleTitle";
    puzzleTitle.innerHTML = "Puzzle " + String(puzzleNum + 1);
    document.body.appendChild(puzzleTitle);

    let gridElement = document.createElement("div");
    gridElement.className = "puzzleGrid";

    document.body.appendChild(gridElement);
    let newElementGrid = [];
    for (let i = 0; i < 9; i++){
        let newRow = [];
        for (let j = 0; j < 9; j++){
            newRow.push(document.createElement("div"));
            newRow[j].className = "tile";
            // makes it black if the tile is "X" (not in puzzle), grey otherwise
            if (puzzle[0][i+1][j+1] == "X"){
                newRow[j].style.backgroundColor = "black";
            } else {
                newRow[j].style.backgroundColor = "lightgrey";
            }
            gridElement.appendChild(newRow[j]);

        }
        newElementGrid.push(newRow);
    }
    for (let i = 0; i < puzzle[1].length; i++){
        let noodle = puzzle[1][i];
        let start = noodle.start;
        let end = noodle.end;
        // -1 because need to convert from 1-9 index in 11x11 grid to 0-8 array
        newElementGrid[start[0]-1][start[1]-1].style.backgroundColor = noodle.colour;
        newElementGrid[start[0]-1][start[1]-1].innerHTML = String(noodle.length);
        newElementGrid[end[0]-1][end[1]-1].style.backgroundColor = noodle.colour;
        newElementGrid[end[0]-1][end[1]-1].innerHTML = String(noodle.length);
    }

    // creating the button
    let solButton = document.createElement("button");

    solButton.innerHTML = "Toggle Solution";
    solButton.className = "solutionButton";

    solButton.onclick = function () {
        show_sol_pressed(puzzleNum);
    }

    let centreDiv = document.createElement("div");
    centreDiv.className = "centre";
    document.body.appendChild(centreDiv);
    centreDiv.appendChild(solButton);

    activePuzzles.push([false,puzzle,newElementGrid,solButton]);

    document.body.appendChild(document.createElement("br"));
    document.body.appendChild(document.createElement("br"));
}

function show_sol_pressed (puzzleNum){
    //console.log(puzzleNum);
    let puzzleData = activePuzzles[puzzleNum]; // [solutionShowing (true/false), puzzle, elementGrid, button object]
    let solutionGrid = puzzleData[1][0];
    let elementGrid = puzzleData[2];
    let noodleList = puzzleData[1][1];
    // if the solution IS NOT currently being showed
    if (puzzleData[0] == false) {
        console.log("Showing solution...");
        activePuzzles[puzzleNum][0] = true;
        // replace shown grid with solution grid
        // note going 0-8, but solution grid uses 1-9 so +1s included later
        for (let i = 0; i < 9; i++){
            for (let j = 0; j < 9; j++){
                // each string in the grid starts with a number to say which order they're in
                let tileNum = parseInt(solutionGrid[i+1][j+1]);
                // removes number to get the colour
                // sets the colour of the tile to be that colour
                let tileIcon = solutionGrid[i+1][j+1].replace(/[0-9]/g, '');
                if (tileIcon != "X"){
                    let tileColour = noodleList[noodleList.map(x => x.icon).indexOf(tileIcon)].colour;
                    elementGrid[i][j].style.backgroundColor = tileColour;
                }
                

                // checking adjacent tiles to see what string it should contain
                let adjacentTiles = get_adjacent(solutionGrid,i+1,j+1);
                // contains two numbers based off where the noodle went before and after the current tile
                // 4 is default value and will only remain if it is the start or end
                // 0 = down, 1 = up, 2 = right, 3 = left
                let beforeAfter = [4,4];
                for (let k = 0; k < 4; k++){
                    // if the tile is the same noodle (icon)
                    if (adjacentTiles[k].replace(/[0-9]/g, '') == tileIcon){
                        // checks for tiles before or after in the noodle
                        if (parseInt(adjacentTiles[k]) == (tileNum-1)){
                            beforeAfter[0] = k;
                        } else if (parseInt(adjacentTiles[k]) == (tileNum+1)){
                            beforeAfter[1] = k;
                        }
                    }

                }
                // if it IS the start or end of a noodle
                // sets string to the noodles length
                if (beforeAfter.includes(4)) {
                    let noodleList = puzzleData[1][1];
                    for (let k = 1; k < noodleList.length; k++){
                        if (noodleList[k].icon == tileIcon){
                            elementGrid[i][j].innerHTML = String(noodleList[k].length);
                        }
                    }
                // if it IS NOT the start or the end, looks up the corresponding line to draw
                // sets the inner html to that string
                } else {
                    let correspondingStrings = [[[0,1],"&#x2502"],[[0,2],"&#x250C"],[[0,3],"&#x2510"],[[1,0],"&#x2502"],[[1,2],"&#x2514"],[[1,3],"&#x2518"],[[2,0],"&#x250C"],[[2,1],"&#x2514"],[[2,3],"&#x2500"],[[3,0],"&#x2510"],[[3,1],"&#x2518"],[[3,2],"&#x2500"]];
                    for (let k = 0; k < 12; k++){
                        if (are_arrays_equal(beforeAfter,correspondingStrings[k][0])){
                            elementGrid[i][j].innerHTML = correspondingStrings[k][1];
                        }
                    }
                }
            }
        }
    // if the solution IS currently being showed
    } else {
        console.log("Showing puzzle...");
        // clear all tiles in the grid
        for (let i = 0; i < 9; i++){
            for (let j = 0; j < 9; j++){
                if (solutionGrid[i+1][j+1] == "X"){
                    elementGrid[i][j].style.backgroundColor = "black";
                } else {
                    elementGrid[i][j].style.backgroundColor = "lightgrey";
                }
                elementGrid[i][j].innerHTML = "";
            }
        }
        // for each noodle, fill the start and end
        for (let i = 0; i < noodleList.length; i++){
            let noodle = noodleList[i];
            let start = noodle.start;
            let end = noodle.end;
            // note -1 because need to convert from string grid 1-9 to element grid 0-8
            elementGrid[start[0]-1][start[1]-1].style.backgroundColor = noodle.colour;
            elementGrid[start[0]-1][start[1]-1].innerHTML = String(noodle.length);
            elementGrid[end[0]-1][end[1]-1].style.backgroundColor = noodle.colour;
            elementGrid[end[0]-1][end[1]-1].innerHTML = String(noodle.length);
        }
        



        activePuzzles[puzzleNum][0] = false;
    }
}

//A bunch of functions from the generator.js file
//Used to check whether a grid is fillable

function min_distance(start,end){
	return (Math.abs(start[0] - end[0]) + Math.abs(start[1] - end[1]));
}

//returns strings in adjacent cells in order [below,above,right,left]
function get_adjacent(grid,row,column){ 
	return [grid[row + 1][column],grid[row - 1][column],grid[row][column + 1],grid[row][column - 1]];
}

//returns list of strings of unique numbers adjacent to cell in descending order
function get_adjacent_num(grid,row,column){ 
    let nums = [];
    let adjCells = get_adjacent(grid,row,column);
    for (let i = 0;i<4;i++){
        // if cell is a number AND is not already in array
        // for some reason " " is considered a number so theres the extra check in there
        if((!isNaN(adjCells[i]) && (adjCells[i] != " ")) && (!nums.includes(adjCells[i]))){
            nums.push(adjCells[i]);
        }
    }
    //sorts in descending order
    //note sort does alphabetical sort by default, NOT numerical
    nums.sort(function(a, b) {
        return a - b;
      });
    nums.reverse();
    return nums;
}

// returns a list of the size of each "gap" in the grid (groups of " " spaces adjacent to each other)
// adjacent being up right left down
function count_gaps(grid){
    let tempGrid = structuredClone(grid);
    let nextNum = 0;
    //list of strings of numbers currently on the grid
    let finalNums = [];
    //tracks how much the number of the same index in finalNums is used
    let numCounts = []; 
    for (let i = 1; i < 10; i++){
        for (let j = 1; j < 10; j++){
            //skips over non empty spaces
            if (tempGrid[i][j] != " "){
                continue
            }
            let adjNums = get_adjacent_num(tempGrid,i,j);
            //if no adjacent numbers, uses a new one
            if (adjNums.length == 0){
                tempGrid[i][j] = String(nextNum);
                finalNums.push(String(nextNum));
                numCounts.push(1)
                nextNum = nextNum + 1;
            // if one number adjacent, uses that
            } else if (adjNums.length == 1) {
                tempGrid[i][j] = adjNums[0];
                // updates count of that number in numCounts
                let numIndex = finalNums.indexOf(adjNums[0]);
                numCounts[numIndex] = numCounts[numIndex] + 1;
            } else {
                //takes lowest number from adjacent numbers
                let remainNum = adjNums.pop();
                //changes current tile to the lower number and updates the count
                tempGrid[i][j] = remainNum;
                let remainIndex = finalNums.indexOf(remainNum);
                numCounts[remainIndex] = numCounts[remainIndex] + 1;

                //removes other numbers from the list of used numbers
                for (let k = 0; k < adjNums.length; k++){
                    let numIndex = finalNums.indexOf(adjNums[k]);
                    finalNums.splice(numIndex,1);
                    numCounts.splice(numIndex,1);
                }
                //remainIndex = finalNums.indexOf(remainNum);
                //replaces said numbers with the lowest one
                for (let k = 1; k <= i; k++){
                    for (let l = 1; l <= 9; l++){
                        if (adjNums.includes(tempGrid[k][l])){
                            tempGrid[k][l] = remainNum;
                            numCounts[remainIndex] = numCounts[remainIndex] + 1;
                        }
                    }
                }
            }
        }
    }
    return numCounts;
}

// returns [[list of sums], list of combinations [4,4,6,etc] at corresponding index]
// note affects original list
function get_combinations_recur(lengthList){
    if (lengthList.length == 0){
        return [[0],[[]]];
    }
    let current = lengthList.pop();
    let otherCombs = get_combinations_recur(lengthList);
    let allCombs = [otherCombs[0].concat(otherCombs[0].map(n => n + current)),otherCombs[1].concat(otherCombs[1].map(x => x.concat([current])))];
    return allCombs;

}

// returns [[list of sums], list of combinations [4,4,6,etc] at corresponding index]
// does not affect original list
// does not include the zero sum
function get_combinations(lengthList){
    let tempList = structuredClone(lengthList);
    let results = get_combinations_recur(tempList);
    // removes the 0 combination (and corresponding [] used to sum to it)
    results[0].shift();
    results[1].shift();
    return results;
}

// returns true if the integers in lengthList can be summed to create the integers in gapList
// (otherwise false)
// each integer in lengthList only being used once
// works recursively, picking one gap seeing if it can be summed with the lengths
// ... then repeating with the remaining gaps and lengths
// cannot be over or under, must be exact
function still_fillable(gapList,lengthList){
    // if all lengths are used, then it is fillable (terminating case for recursion)
    if (lengthList.length == 0){
        return true
    }
    let remainingGaps = structuredClone(gapList);
    let gap = remainingGaps.pop();
    let combinations = get_combinations(lengthList);
    let valid = [];
    // if it is not possible to fill the current gap with the remaining lengths
    // returns false (not still fillable)
    if (!combinations[0].includes(gap)){
        return false;
    // gets every combination of lengths that can fill said gap
    } else {
        for (let i = 0; i < combinations[0].length; i++){
            if (combinations[0][i] == gap){
                valid.push(combinations[1][i]);
            }
        }
    }
    // for each combination, repeats the function with the remaining gaps and lengths
    // if any of them are true, then it is still fillable
    // if not, then it is not
    let fillable = false;
    for (let i = 0; i < valid.length; i++){
        // comb is a list of integers that add to the current gap
        let comb = valid[i]
        let remainingLengths = structuredClone(lengthList);
        // removes all numbers in comb from the list of lengths
        for (let j = 0; j < comb.length;j++){
            let numIndex = remainingLengths.indexOf(comb[j]);
            remainingLengths.splice(numIndex,1);
        }
        if (still_fillable(remainingGaps,remainingLengths)){
            fillable = true;
        }
    }
    return fillable;
}

function are_arrays_equal(array1,array2){
	if (array1.length != array2.length){
		return false;
	}
	for (let i = 0; i<array1.length; i++){
		if (array1[i] != array2[i]){
			return false;
		}
	}
	return true;

}

</script>
</body>
</html>

