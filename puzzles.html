<!DOCTYPE html>
<html>

<head>
    <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet'>
    <link rel="stylesheet" href="stylesheet.css">
</head>

<body>

    <!-- Navigation Bar -->
    <div class = "navBar">
        <img src = "logo.png" class = "logo"> 
        Noodle Puzzle Generator
        <div style = "width:5%"></div>
        <a href="index.html" class="hyperButton">Generate Puzzles</a>
        <a href="puzzles.html?difficulty=Tutorial" class="hyperButton activeButton">Review Puzzles</a>
        <a href="final.html" class="hyperButton">Final Puzzles</a>
    </div>

    <br>

    <div class = "row">

        <!-- Buttons for selecting difficulty to view -->
        <div class = "reviewDifficultyBar">
            Select difficulty to review:
            <a id="reviewDifficultyButtonTutorial" href="puzzles.html?difficulty=Tutorial" class="hyperButton" >Tutorial</a>
            <a id="reviewDifficultyButtonEasy" href="puzzles.html?difficulty=Easy" class="hyperButton">Easy</a>
            <a id="reviewDifficultyButtonMedium" href="puzzles.html?difficulty=Medium" class="hyperButton">Medium</a>
            <a id="reviewDifficultyButtonHard" href="puzzles.html?difficulty=Hard" class="hyperButton">Hard</a>
        </div>

        <!-- Entry for choosing username to review as-->
        <div class = "reviewUsernameBar">
            Enter username:   
            <input type="text" id="usernameEntry" oninput="username_typed()">
        </div>

    </div>

    <br>

    <!-- Displays which difficulty is selected and the amount saved/finalised-->
    <div id = "puzzleReviewTitle" style="font-size: 30px; text-decoration:underline">Loading...</div>

    <br>

    <!-- Contains all puzzles displayed-->
    <div id = "puzzleReviewContainer"></div>


    <!-- Default puzzle display that can be copied later-->
    <div id = "puzzleReviewDefault" class = "puzzleReviewDisplay">
            
        <!-- Left column of puzzle review info-->
        <div class = "puzzleReviewLeft">

            <div class = "puzzleReviewID">Puzzle ID: Default</div>

            <br>

            Noodle Colours:
            <div class = "puzzleReviewNoodles"></div>

            <br>

            <div class = "puzzleReviewNoodleCount"></div>

            <br>

            <div class = "hyperButton puzzleReviewToggleButton">Toggle Solution</div>

        </div>

        <!-- Grid for puzzle review -->
        <div class = "puzzleReviewGrid">
            <div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div>
            <div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div>
            <div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div>
            <div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div>
            <div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div>
            <div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div>
            <div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div>
            <div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div>
            <div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div><div class="puzzleReviewTile"></div>
        </div>

        <!-- Right column of puzzle review info-->
        <div class = "puzzleReviewRight">

            <!-- Difficulty text and buttons-->
            Difficulty (Click to change)

            <div class = "hyperButton difficultyButton">Tutorial</div>
            <div class = "hyperButton difficultyButton">Easy</div>
            <div class = "hyperButton difficultyButton">Medium</div>
            <div class = "hyperButton difficultyButton">Hard</div>

            <br>

            <!-- Ratings Section-->
            Ratings: 
            <br>
            <div class = "ratingsDiv"></div>

            <br>

            <!-- Contains the buttons (with images of thumbs up/down) for ratings-->
            <!-- If current username has already given a rating, displays a red "remove rating" button instead-->
            <div class = "puzzleReviewRatingsButtons">
                <div class = "hyperButton ratingButton">&#128077</div>
                <div class = "hyperButton ratingButton">&#128078</div>
            </div>
            <br>

            <!-- Finalise Button-->
            <div class = "puzzleReviewFinaliseButton">Finalise</div>

            <br>
            
            <!-- Delete Button-->
            <!-- Note: should have a pop-up to confirm-->
            <div class = "puzzleReviewDeleteButton">Delete</div>

        </div>

    </div>



<!--Utility (doesnt affect page) Functions Script-->
<script src="utilityfunctions.js"></script>

<!--Installing Database Script-->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<!--Database Code-->
<script src="databasescript.js"></script>

<!--Main code-->
<script>

// -----===== GLOBAL VARIABLES =====-----

// the difficulty selected
// string with first letter capitalised
const globalDifficulty = new URLSearchParams(window.location.search).get("difficulty");

// array of puzzle objects corresponding to the current difficulty
let globalPuzzles = [];

// quotas for amount of saved and finalised puzzles
// used for titles of the review page
// in order [Tutorial, Easy, Medium, Hard]
const globalSavedQuotas = [5,20,20,20]; 
const globalFinalisedQuotas = [5,20,20,20]; 

// tracks whether solutions are toggled on or off
let globalSolutionToggles = [];

// -----===== MAIN PROGRAM =====-----

on_load();

// -----===== FUNCTIONS =====-----

// runs on the page loading
async function on_load () {

    // updates the difficulty buttons to highlight the current one
    update_difficulty_buttons(globalDifficulty);

    // loads globalPuzzles
    globalPuzzles = await get_puzzles_of_difficulty(globalDifficulty);

    // debug
    console.log(globalPuzzles);

    // sets every solution to be toggled off by default
    for (let i = 0; i < globalPuzzles; i++){
        globalSolutionToggles.push(false);
    }

    // if theres a username in local storage, uses that
    let localUsername = localStorage.getItem("username");
    if (localUsername != null){
        document.getElementById("usernameEntry").value = localUsername;
    }

    // creates elements for every puzzle display and adds them to the page
    update_display();

}

// removes a puzzle locally and keeps everything else correct
function remove_local_puzzle(puzzle){

    let puzzleIndex = globalPuzzles.indexOf(puzzle);

    // removes it from local array of puzzles
    globalPuzzles.splice(puzzleIndex,1);

    // removes it from array of solution toggles
    globalSolutionToggles.splice(puzzleIndex,1);

    update_display();

}

// creates elements for every puzzle display and adds them to the page
function update_display (){

    // shorthand for globalPuzzles
    let puzzles = globalPuzzles;

    // the div element containing all the display divs
    let containerDiv = document.getElementById("puzzleReviewContainer");

    // clears the container div of anything there before
    containerDiv.innerHTML = "";

    // Updates title with difficulty, amount saved, amount finalised
    update_title();

    // for each puzzle:
    for (let i = 0; i < puzzles.length; i++){

        // shorthands
        let puzzle = puzzles[i];
        let noodles = puzzle.noodles;

        // CREATE A REVIEW ELEMENT FOR THE PUZZLE:

        // clones the review display template
        // true parameter means it also copies all its children
        let newReviewDiv = document.getElementById("puzzleReviewDefault").cloneNode(true);
        newReviewDiv.id = "reviewDiv" + String(i);

        // adds it to the page
        containerDiv.appendChild(newReviewDiv);

        // FOR LEFT COLUMN:
        let leftColumnDiv = newReviewDiv.firstElementChild;

        // updates puzzle ID text
        let puzzleIdDisplay = leftColumnDiv.getElementsByClassName("puzzleReviewID").item(0);
        puzzleIdDisplay.innerHTML = "Puzzle ID: " + String(puzzle.puzzleId);

        // updates list of noodle colours
        let noodleColoursDisplay = leftColumnDiv.getElementsByClassName("puzzleReviewNoodles").item(0);

        // array of unique noodle colours in the puzzle
        // their lengths
        // the amount of times they appear at the corresponding index in colourLengths
        let uniqueColours = [];
        let colourLengths = [];
        let colourCounts = [];
        for (let j = 0; j < noodles.length; j++){
            let noodle = noodles[j];
            if (!uniqueColours.includes(noodle.colour)) {
                uniqueColours.push(noodle.colour);
                colourLengths.push(noodle.length);
                colourCounts.push(1);
            } else {
                let colourIndex = uniqueColours.indexOf(noodle.colour);
                colourCounts[colourIndex] = colourCounts[colourIndex] + 1;
            }
        }

        // for each unique colour, adds a line to the display (in the corresponding colour)
        for (let j = 0; j < uniqueColours.length; j++){
            let newRow = document.createElement("div");
            newRow.innerHTML = colourCounts[j] + "x " + uniqueColours[j] + " (" + colourLengths[j] + ")<br>";
            // if its an obstacle, says that instead of the colour
            if (colourLengths[j] == 1){
                newRow.innerHTML = colourCounts[j] + "x Obstacle";
            }
            newRow.style.backgroundColor = uniqueColours[j];
            noodleColoursDisplay.appendChild(newRow);
        }

        // updates count of noodles
        let noodleCountDisplay = leftColumnDiv.getElementsByClassName("puzzleReviewNoodleCount").item(0);
        noodleCountDisplay.innerHTML = "Total: " + String(noodles.length) + " noodles";

        // FOR GRID:
        let gridDiv = leftColumnDiv.nextElementSibling;

        // corresponding elements to the 2d grid array (also a 2d array)
        // note this is 0-8 indexed unlike the grid which is 1-9 indexed
        let gridElements = [];
        let currentElement = gridDiv.firstElementChild;
        for (let j = 0; j < 9; j++){
            let newRow = [];
            for (let k = 0; k < 9; k++){
                newRow.push(currentElement);
                currentElement = currentElement.nextElementSibling;
            }
            gridElements.push(newRow);
        }

        // updates the tiles to show the puzzle unsolved
        show_grid_unsolved(puzzle, gridElements);

        // Updates toggle solution button onclick
        let toggleSolButton = leftColumnDiv.getElementsByClassName("puzzleReviewToggleButton").item(0);
        toggleSolButton.onclick = function () {
            toggle_sol_pressed(puzzle,toggleSolButton,gridElements);
        }

        // FOR RIGHT COLUMN:
        let rightColumnDiv = gridDiv.nextElementSibling;

        // updates difficulty button to have current one highlighted
        // and to have the correct onclick
        let puzzleDifficultyButtons = rightColumnDiv.getElementsByClassName("difficultyButton");
        for (let j = 0; j < puzzleDifficultyButtons.length; j++){

            let currentButton = puzzleDifficultyButtons.item(j);

            // updates highlight
            if (currentButton.innerHTML == globalDifficulty){
                currentButton.classList.add("activeButton");
            }

            // updates onclick
            currentButton.onclick = function () {
                difficulty_pressed(puzzle, currentButton.innerHTML);
            }


        }

        // Displays ratings
        let ratingsDiv = rightColumnDiv.getElementsByClassName("ratingsDiv").item(0);
        for (let j = 0; j < puzzle.ratings.length; j++ ){
            // adds the rating as text to the div
            ratingsDiv.innerHTML = ratingsDiv.innerHTML + puzzle.ratings[j] + "<br>";
        }

        // Updates Rating Buttons
        let ratingButtonsDiv = rightColumnDiv.getElementsByClassName("puzzleReviewRatingsButtons").item(0);

        // the username currently entered into the input box
        let username = document.getElementById("usernameEntry").value;

        if (username == "") {
            ratingButtonsDiv.innerHTML = "Please enter a username<br>to rate this puzzle."
        } else {
            let alreadyRated = false;

            for (let j = 0; j < puzzle.ratings.length; j++){
                // removes the emoji and check if this user is the same as the one that left the rating
                if (username == puzzle.ratings[j].replace("&#128077", "").replace("&#128078", "")){

                    alreadyRated = true;

                    // replaces the thumbs up and down buttons with button to remove your rating
                    ratingButtonsDiv.firstElementChild.remove()
                    let newButton = ratingButtonsDiv.firstElementChild;
                    newButton.innerHTML = "Remove Rating";
                    newButton.onclick = function () {
                        remove_rating_pressed(puzzle,username);
                    }
                }
            }

            if (!alreadyRated){

                // give the thumbs up and down buttons onclick events
                let ratingButtons = ratingButtonsDiv.getElementsByClassName("ratingButton");

                // thumbsup button
                ratingButtons.item(0).onclick = function () {
                    rating_button_pressed(puzzle,"&#128077",username);
                }
                // thumbsdown button
                ratingButtons.item(1).onclick = function () {
                    rating_button_pressed(puzzle,"&#128078",username);
                }


            }
        }


        // Updates finalise button onclick
        // calls the function with puzzle's id and button so it can be updated on the database
        // flips the puzzle's finalised status
        let finaliseButton = rightColumnDiv.getElementsByClassName("puzzleReviewFinaliseButton").item(0);
        finaliseButton.onclick = function () {
            finalise_pressed(puzzle,finaliseButton);
        }

        // If its already been finalised, replaces text with "Unfinalise"
        if (puzzle.finalised == true){
            finaliseButton.innerHTML = "Unfinalise";
            finaliseButton.style.backgroundColor = "lime";
        }

        // Updates delete button onclick
        let deleteButton = rightColumnDiv.getElementsByClassName("puzzleReviewDeleteButton").item(0);
        deleteButton.onclick = function () {
            delete_pressed(puzzle,deleteButton);
        }

        // adds a gap after it
        containerDiv.appendChild(document.createElement("br"));
        containerDiv.appendChild(document.createElement("br"));

    }

}

// updates the title with the current difficulty, amount saved, and amount finalised
// note does not accurately represent changes in amount saved unless page is refreshed
function update_title (){

    // amount of saved and finalised puzzles
    let savedCount = globalPuzzles.length;
    let finalisedCount = 0;

    // for each puzzle, increments savedCount and finalisedCount if applicable (all of them are saved)
    for (let i = 0; i < globalPuzzles.length; i++){
        if (globalPuzzles[i].finalised == true){
            finalisedCount = finalisedCount + 1;
        }
    }

    let difficultyIndex = ["Tutorial","Easy","Medium","Hard"].indexOf(globalDifficulty);

    // updates title text
    document.getElementById("puzzleReviewTitle").innerHTML = 
        globalDifficulty + 
        " (" + String(savedCount) + "/" + globalSavedQuotas[difficultyIndex] + " Saved)" +
        " (" + String(finalisedCount) + "/" + globalFinalisedQuotas[difficultyIndex] + " Finalised)";

}

// runs when the toggle solution button is pressed
function toggle_sol_pressed (puzzle,toggleSolButton, gridElements) {

    let puzzleIndex = globalPuzzles.indexOf(puzzle);

    // whether it is now toggled on or off
    let newToggleState = !globalSolutionToggles[puzzleIndex];

    // updates the saved toggle state
    globalSolutionToggles[puzzleIndex] = newToggleState;

    if (newToggleState == true){
        show_grid_solved(puzzle,gridElements);
    } else {
        show_grid_unsolved(puzzle, gridElements);
    }

}

// updates the given grid to be the solved puzzle
function show_grid_solved (puzzle, gridElements) {

    // note this is copy pasted from the generated version
    // so just adapting to the variable names here
    let solutionGrid = puzzle.grid;
    let elementGrid = gridElements;
    let noodleList = puzzle.noodles;

    // note going 0-8, but solution grid uses 1-9 so +1s included later
    for (let i = 0; i < 9; i++){
        for (let j = 0; j < 9; j++){

            // each string in the grid starts with a number to say which order they're in
            let tileNum = parseInt(solutionGrid[i+1][j+1]);

            // removes number to get the icon
            let tileIcon = solutionGrid[i+1][j+1].replace(/[0-9]/g, '');

            // sets the colour of the tile to be the corresponding colour of the noodle with that icon
            if (tileIcon != "X"){
                let tileColour = noodleList[noodleList.map(x => x.icon).indexOf(tileIcon)].colour;
                elementGrid[i][j].style.backgroundColor = tileColour;
            }
            
            // checking adjacent tiles to see what string it should contain
            let adjacentTiles = get_adjacent(solutionGrid,i+1,j+1);

            // contains two numbers based off where the noodle went before and after the current tile
            // 4 is default value and will only remain if it is the start or end
            // 0 = down, 1 = up, 2 = right, 3 = left
            let beforeAfter = [4,4];
            for (let k = 0; k < 4; k++){

                // if the tile is the same noodle (icon)
                if (adjacentTiles[k].replace(/[0-9]/g, '') == tileIcon){

                    // checks for tiles before or after in the noodle
                    if (parseInt(adjacentTiles[k]) == (tileNum-1)){
                        beforeAfter[0] = k;
                    } else if (parseInt(adjacentTiles[k]) == (tileNum+1)){
                        beforeAfter[1] = k;
                    }
                }
            }

            // if it IS the start or end of a noodle
            // sets string to the noodles length
            if (beforeAfter.includes(4)) {
                for (let k = 1; k < noodleList.length; k++){
                    if (noodleList[k].icon == tileIcon){
                        elementGrid[i][j].innerHTML = String(noodleList[k].length);
                    }
                }

            // if it IS NOT the start or the end, looks up the corresponding line to draw
            // sets the inner html to that string
            } else {

                // array that correlates beforeAfter to a unicode symbol with the right line
                let correspondingStrings = [[[0,1],"&#x2502"],[[0,2],"&#x250C"],[[0,3],"&#x2510"],[[1,0],"&#x2502"],[[1,2],"&#x2514"],[[1,3],"&#x2518"],[[2,0],"&#x250C"],[[2,1],"&#x2514"],[[2,3],"&#x2500"],[[3,0],"&#x2510"],[[3,1],"&#x2518"],[[3,2],"&#x2500"]];
                
                // loops through each possible line
                for (let k = 0; k < 12; k++){
                    if (are_arrays_equal(beforeAfter,correspondingStrings[k][0])){
                        elementGrid[i][j].innerHTML = correspondingStrings[k][1];
                    }
                }
            }
        }
    }

}

// updates the given grid to be the unsolved puzzle
function show_grid_unsolved (puzzle, gridElements) {

    // 2d array of SOLVED grid (still has correct "X"s for unsolved puzzle)
    let grid = puzzle.grid;

    // for every tile (note i and j are 1-9 indexed, while gridElements is 0-9 indexed)
    // fills in blocked off spaces, and rest are coloured lightgrey
    for (let i = 1; i < 10; i++){
        for (let j = 1; j < 10; j++){

            if (grid[i][j] == "X"){
                // -1 to account for difference in indexing
                gridElements[i-1][j-1].style.backgroundColor = "black";
            } else {
                gridElements[i-1][j-1].style.backgroundColor = "lightgrey";
            }

            // clears any text that was there previously
            gridElements[i-1][j-1].innerHTML = "";
        }
    }

    // list of noodle objects for the current puzzle
    let noodles = puzzle.noodles;

    // colouring in the noodle starts and ends with the corresponding colour
    for (let i = 0; i < noodles.length; i++){
        let noodle = noodles[i];
        let start = noodle.start;
        let end = noodle.end;
        // -1 because need to convert from 1-9 index in 11x11 grid to 0-8 array
        gridElements[start[0]-1][start[1]-1].style.backgroundColor = noodle.colour;
        gridElements[start[0]-1][start[1]-1].innerHTML = String(noodle.length);
        gridElements[end[0]-1][end[1]-1].style.backgroundColor = noodle.colour;
        gridElements[end[0]-1][end[1]-1].innerHTML = String(noodle.length);
    }
}

// runs when a difficulty button is pressed
function difficulty_pressed(puzzle, difficulty) {

    console.log("difficulty pressed");

    // does nothing if current difficulty clicked
    if (difficulty == globalDifficulty){
        return;
    }

    // updates database
    update_puzzle_difficulty(puzzle.puzzleId, difficulty);

    // removes it from the local puzzle list
    remove_local_puzzle(puzzle);

}

// runs when a rating button is pressed
function rating_button_pressed (puzzle, emoji, username){

    // adds to local list
    puzzle.ratings.push(emoji + username);

    // update the database
    update_puzzle_ratings(puzzle.puzzleId,String(puzzle.ratings));

    // update the display
    update_display();



}

// runs when the "Remove Rating" button is pressed
// (only exists if the username has already rated a puzzle)
function remove_rating_pressed (puzzle, username) {

    // list of ratings without emojis (just usernames)
    let ratingUsernames = puzzle.ratings.map(x => x.replace("&#128077", "").replace("&#128078", ""));

    // removes the rating of the given username
    let removeIndex = ratingUsernames.indexOf(username);
    puzzle.ratings.splice(removeIndex,1);

    // update the database
    update_puzzle_ratings(puzzle.puzzleId,String(puzzle.ratings));

    // update the display
    update_display();

}

// runs when the finalise button for a puzzle is pressed
function finalise_pressed (puzzle, finaliseButton){

    // updates the value in the local copy of the puzzle
    let newFinalised = !puzzle.finalised;
    puzzle.finalised = newFinalised;
    
    // sets the finalised column of the puzzle in the "puzzles" database to true
    finalise_puzzle(puzzle.puzzleId,newFinalised);

    // Updates text and colour to the reverse option
    if (puzzle.finalised == true){
        finaliseButton.innerHTML = "Unfinalise";
        finaliseButton.style.backgroundColor = "lime";
    } else {
        finaliseButton.innerHTML = "Finalise";
        finaliseButton.style.backgroundColor = "green";
    }

    // updates the finalised count in the title
    update_title();
}

// runs when the delete button is pressed
function delete_pressed(puzzle, deleteButton) {

    // causes a popup the user must accept to proceed
    if (window.confirm("Are you sure you want to delete this puzzle? (ID: " + String(puzzle.puzzleId) +")")){

        // updates the database so that it is not saved
        delete_puzzle(puzzle.puzzleId);

        // removes it from the local puzzle list
        remove_local_puzzle(puzzle);

    }

}

// gets the corresponding difficulty button and adds the "activeButton" class to it
function update_difficulty_buttons(difficulty) {

    // gets corresponding button
    let buttonElement = document.getElementById("reviewDifficultyButton" + difficulty);

    // adds activeButton class (changes its colour)
    buttonElement.classList.add("activeButton");

}

// runs when the username field is typed in
function username_typed () {

    console.log(document.getElementById("usernameEntry").value);

    // refreshes puzzle displays so the review buttons are updated
    update_display();

    // updates localstorage to track this username for future use
    localStorage.setItem("username", document.getElementById("usernameEntry").value);
}

</script>

</body>
</html>